
## 进程和信号

	进程和信号构成了Linux操作环境的基础部分，它们控制着Linux和所有其他类UNIX系统执行的几乎所有活动
	怎样知道计算机在任一给定时刻在做些什么
	如何在自己的程序中启动和停止其他的进程
	如何让进程收发消息
	如何避免僵尸进程等
	
	进程的结构、类型和调度
	用不同的方法启动新进程
	父进程、子进程和僵尸进程
	信号及其使用

#### 什么是进程
	
	UNIX标准把进程定义为：一个其中运行着一个或多个线程的地址空间和这些线程所需要的系统资源
	每个运行着的程序实例就构成一个进程
	正在运行的程序或进程由程序代码、数据、变量（占用着系统内存）、打开的文件（文件描述符）和环境组成
	Linux系统会在进程之间共享程序代码和系统函数库，所以在任何时刻内存中都只有代码的一份副本

#### 进程的结构

	ps -ef，打印进程相关信息，包括启动进程的命令、用户等
	进程标识符或PID：进程被分配的一个唯一的数字编号，取值范围通常是2～32768的正整数
	进程被启动时系统按顺序选择下一个未被使用的数字作为PID，当数字回绕一圈时，新的PID重新从2开始
	数字1一般是为init进程保留的
	程序代码被保存在一个磁盘文件中，Linux进程不能对 用来存放程序代码的内存区域进行写操作，即程序代码是以只读方式加载到内存中的，这个区域可以被多个进程安全地共享
	系统函数库可以被共享，与Windows的动态链接库（DLL）机制类似
	进程有自己的栈空间， 用于保存函数中的局部变量和控制函数的调用与返回
	进程有自己的环境空间，包含专门为这个进程建立的环境变量
	进程必须维护自己的程序计数器，用来记录它执行到的位置，即在执行线程中的位置
	/proc目录中有一组特殊的文件，通过它们可以窥视正在运行的进程的内部情况
	Linux有一个虚拟内存系统，能够把程序代码和数据以内存页面的形式放到硬盘的一个区域中，所以Linux可以管理的进程比物理内存所能容纳的要多得多

	进程表：
		Linux进程表就像一个数据结构，它把当前加载在内存中的所有进程的有关信息保存在一个表中，其中包括进程的PID、进程的状态、命令字符串和其他一些ps命令输出的各类信息
		PID是进程表的索引，操作系统通过PID对进程进行管理
		进程表的长度是有限制的，所以操作系统能够支持的同时运行的进程数也是有限制的
		现在可以同时运行的进程数可能只与用于建立进程表项的内存容量有关，而没有具体的数字限制

	查看进程：
		ps命令可以显示正在运行的进程、其他用户正在运行的进程或目前系统上运行的所有进程
		ps -ef，显示进程信息，如：TTY列显示进程是从哪一个终端启动的，TIME列是进程目前为止所占用的CPU时间，CMD列显示启动进程所使用的命令
		默认情况下，ps只显示与终端、主控台、串行口或伪终端保持连接的进程的信息
		其他进程在运行时不需要通过终端与用户进行通信，通常是一些系统进程，Linux用它们来管理共享的资源
		ps -a，查看所有的进程， -f 选项显示进程完整的信息
		ps其他用法见手册页

	系统进程：
		ps ax，命令输出中的STAT列用来表明进程的当前状态
		STAT代码：
			S，睡眠，通常是在等待某个事件的发生，如一个信号或有输入可用
			R，运行，可运行，即在运行队列中，处于正在执行或即将运行状态
			D，不可中断的睡眠（等待），通常是在等待输入或输出完成
			T，停止，通常是被shell作业控制所停止，或者进程正处于调试器的控制之下
			Z，死（Defunct）进程或僵尸（zombie）进程
			N，低优先级任务，nice
			W，分页
			s，进程是会话期首进程
			+，进程属于前台进程组
			l，进程是多线程的
			<，高优先级任务
		Linux启动时，将运行一个名为init的进程，它是系统运行的第一个进程，进程号为1，可以把init进程看作为操作系统的进程管理器，它是所有其他进程的祖先进程
		启动新进程并等待它们结束的能力是整个系统的基础
		系统调用：fork、exec、wait

	进程调度：
		在单处理器计算机上，同一时间只能有一个进程可以运行，其他进程处于等待运行状态，每个进程轮到的运行时间（称之为时间片）是相当短暂的，这就给人一种多个程序在同时运行的假象
		R+状态只表示这个程序是一个前台任务，它不是在等待其他进程结束或等待输入输出操作完成
		Linux内核用进程调度器来决定下一个时间片应该分配给哪个进程，它的判断依据是进程的优先级
		优先级高的进程运行得更为频繁，其他进程，如低优先级的后台任务运行的就不是非常频繁
		Linux中，进程的运行时间不可能超过分配给它们的时间片，它们采用抢先式多任务处理，所以进程的挂起和继续运行无需彼此之间的协作
		
		在多任务系统中，多个程序可能会竞争使用同一个资源，这种情况下，执行短期的突发性工作并暂停运行来等待输入的程序，要比持续占用处理器来进行计算或不断轮询系统来查看是否有新的输入到达的程序要更好
		我们称表现良好的程序为nice程序，在某种意义上，这个nice是可以被计算出来的，操作系统根据进程的nice值来决定它的优先级，一个进程的nice值默认为0并将根据程序的表现而不断变化
		长期不间断运行的程序的优先级一般会比较低，而暂停来等待输入的程序会得到奖励，这可以帮助与用户进行交互的程序保持及时的响应性
		在程序等待用户输入时，系统会增加它的优先级，这样，当它准备继续运行时，它就会有比较高的优先级而能优先执行
		可以用nice命令设置进程的nice值，使用renice命令调整它的值
		nice命令是将进程的nice值增加10，从而降低该进程的优先级
		可以用ps -l或-f选项查看正在运行的进程的nice值，NI列

		ps -l，查看nice值
		nice xxx &，启动xxx，将给xxx分配一个+10的nice值
		renice 10 pid，调整进程的nice值，降低进程优先级，使其运行不频繁
		ps x，查看状态栏，STAT中包含字符N表明这个进程的nice值已被修改过，不再是默认值
		PPID，父进程ID，是启动这个进程的进程的PID，若原来的父进程已经不存在，该栏显示的就是init进程的ID 1

#### 启动新进程

    可以在一个程序的内部启动另一个程序，从而创建一个新进程
    int system(const char *string);     （stdlib.h）
    system作用是运行以字符串参数的形式传递给它的命令并等待该命令的完成，命令执行就如同在shell中执行的命令：sh -c string
    如果无法启动shell来运行这个命令。system返回错误代码127；如果是其他错误，则返回-1，否则返回该命令的退出码
    system通过shell来启动想要执行的程序，所以可以把程序放到后台执行（命令行使用&）
    程序必须等待system函数启动的进程结束之后才能继续，因此不能立刻执行其他任务
    利用shell执行后台任务，对system的调用将在shell命令结束后立刻返回
    system函数必须用一个shell来启动需要的程序，其效率不高，不建议使用
    
    替换进程映像：
        exec系列函数由一组相关函数组成，它们在进程的启动方式和程序参数的表达方式上各有不同
        exec函数可以把当前进程替换为一个新进程，新进程由path或file参数指定
        可以使用exec函数将程序的执行从一个程序切换到另一个程序，新的程序启动后，原来的程序就不再运行了
        char **environ;     （unistd.h）
        int execl(const char *path, const char *arg0, ..., (char *)0);
        int execlp(const char *file, const char *arg0, ..., (char *)0);
        int execle(const char *path, const char *arg0, ..., (char *)0, char *const envp[]);
        int execv(const char *path, char *const argv[]);
        int execvp(const char *file, char *const argv[]);
        int execve(const char *path, char *const argv[], char *const envp[]);
        两大类函数：可变参数，以一个空指针结束；第二个参数是字符串数组；
        新程序启动时会把在argv数组中给定的参数传递给main函数
        以字母p结尾的函数搜索PATH环境变量来查找新程序的可执行文件路径，如果可执行文件不在PATH路径中，就需要把包括目录在内使用绝对路径的文件名作为参数传递给函数
        全局变量environ可用来把一个值传递到新的程序环境中
        函数execle和execve可以通过参数envp传递字符串数组作为新程序的环境变量
        execl("/bin/ps", "ps", "ax", 0);
        对于由exec函数启动的进程，它的参数表和环境加在一起的总长度是有限制的，上限由ARG_MAX给出，POSIX规范要求ARG_MAX至少要有4096个字节，Linux上是128K字节
        一般情况下，exec函数是不会返回的
        出错时exec函数返回-1，并且会设置错误变量errno
        由exec启动的新进程继承了原进程的许多特性，原进程中已打开的文件描述符在新进程中仍保持打开（除非close on exec flag被置位），任何原进程中已打开的目录流都将在新进程中被关闭
        
    复制进程映像：
        要想让进程同时执行多个函数，可以使用线程或从原程序中创建一个完全分离的进程，就像init一样，而不像exec那样替换当前执行的进程
        fork调用创建新进程，复制当前进程，在进程表中创建一个新的表项，新表项中许多属性与当前进程是相同的
        新进程几乎与原进程一模一样，执行的代码也完全相同，但它有自己的数据空间、环境和文件描述符
        fork和exec函数结合在一起使用就是创建新进程所需要的一切了
        pid_t fork(void);   （unistd.h、sys/types.h）
        父进程中fork调用返回的是新子进程的PID，新进程就像原进程一样继续执行
        子进程中的fork返回的是0，父子进程可通过这一点判断父子进程
        fork失败返回-1，失败通常是因为父进程所拥有的子进程数目超过规定的限制（CHILD_MAX），此时errno被设为EAGAIN
        如果是因为进程表里没有足够的空间用于创建新的表单或虚拟内存不足，errno变量将被设为ENOMEM
        
    等待一个进程：
        用fork启动一个子进程时，子进程就有了自己的生命周期并将独立运行
        可以通过在父进程中调用wait函数让父进程等待子进程的结束
        pid_t wait(int *stat_loc);      （sys/types.h，sys/wait.h）
        wait系统调用将暂停父进程直到它的子进程结束为止
        返回子进程的PID，通常是已经结束运行的子进程的PID
        状态信息允许父进程了解子进程的退出状态，即子进程的main函数返回的值或子进程中exit函数的退出码
        如果stat_loc不是空指针，状态信息将被写入它所指向的位置
        用sys/wait.h中定义的宏来解释状态信息：
            WIFEXITED(stat_val)，如果子进程正常结束，它就取一个非0值
            WEXITSTATUS(stat_val)，如果WIFEXITED非0，它返回子进程的退出码
            WIFSIGNALED(stat_val)，如果子进程因为一个未捕获的信号而终止，它就取一个非0值
            WTERMSIG(stat_val)，如果WIFSIGNALED非0，它返回一个信号代码
            WIFSTOPPED(stat_val)，如果子进程意外终止，它就取一个非0值
            WSTOPSIG(stat_val)，如果WIFSTOPPED非0，它返回一个信号代码
        
    僵尸进程：
        子进程终止时，它与父进程之间的关联还会保持，直到父进程也正常终止或父进程调用wait才告结束
        进程表中代表子进程的表项不会立刻释放
        虽然子进程不再运行，但仍存在于系统中，因为它的退出码还需要保存起来，以备父进程今后的wait调用使用，这时它将成为一个死（defunct）进程或僵尸（zombie）进程
        ps -al，可在CMD列看到 <defunct> 或 <zombie> 的即为僵尸进程
        如果子进程变为僵尸进程后父进程异常终止，子进程将自动把PID为1的进程（init）作为自己的父进程，僵尸进程将一直保留在进程表中直到被init进程发现并释放
        在init清理之前，僵尸进程将一直消耗系统资源
        pid_t waitpid(pid_t pid, int *stat_loc, int options);   （sys/wait.h，sys/type.h）
        pid指定需要等待的子进程的PID，等待某个特定子进程的结束
        pid为-1，waitpid将返回任一子进程的信息，stat_loc不是空指针，waitpid将把状态信息写到它所指向的位置
        options参数可用来改变waitpid的行为，其中最有用的是WNOHANG，作用是防止waitpid调用将调用者的执行挂起
        用WNOHANG选项来查找是否有子进程已经结束，如果没有，程序将继续执行。其他选项和wait调用的选项相同
        waitpid(child_pid, (int *)0, WNOHANG); //让父进程周期性检查某个特定的子进程是否已经终止时使用
        如果子进程没有结束或意外终止，返回0，否则返回child_pid，失败返回-1并设置errno
        waitpid失败的情况包括：没有子进程（errno为ECHILD）、调用被某个信号中断（EINTR）或选项参数无效（EINVAL）
        
    输入和输出重定向：
        已打开的文件描述符将在fork和exec调用之后保留下来，可以利用此改变程序的行为
        过滤程序：从标准输入读取数据，然后向标准输出写数据，同时在输入和输出之间对数据做一些有用的转换
        调用execl之后，标准输入会保留下来，可利用重定向从标准输入中读取数据
    
    线程：
        进程可以互相协作、互相发送消息、互相中断，甚至可以共享内存段
        本质上，进程是OS内各自独立的实体，要想共享变量并不容易
        线程 thread，Linux中的进程都是非常轻量级的
        Linux中编写多个互相协作的进程比编写线程要容易得多

#### 信号

    信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动
    术语：生成（raise）表示一个信号的产生，捕获（catch）表示接收到一个信号
    信号是由于某些错误条件而生成的，如内存段冲突、浮点处理器错误或非法指令等
    信号由shell和终端处理器生成来引起中断，还可以作为在进程间传递消息或修改行为的一种方式，明确地由一个进程发送给另一个进程
    信号可以被生成、捕获、响应或忽略（至少对于一些信号）
    信号在signal.h中定义，以SIG开头：
        SIGABORT， *进程异常终止
        SIGALRM， 超时警告
        SIGFPE， *浮点运算异常
        SIGHUP， 连接挂断
        SIGILL， *非法指令
        SIGINT， 终端中断
        SIGKILL， 终止进程（此信号不能被捕获或忽略）
        SIGPIPE， 向无读进程的管道写数据
        SIGQUIT， 终端退出
        SIGSEGV， *无效内存段访问
        SIGTERM， 终止
        SIGUSR1， 用户定义信号1
        SIGUSR2， 用户定义信号2
    如果进程接收到这些信号中的一个，但事先没有安排捕获它，进程将会立刻终止
    通常，系统将生成核心转储文件core，并将其放在当前目录下，该文件是进程在内存中的映像，对调试很有用
    其他信号：
        SIGCHLD， 子进程已经停止或退出
        SIGCONT， 继续执行暂停进程
        SIGSTOP， 停止执行（此信号不能被捕获或忽略）
        SIGTSTP， 终端挂起
        SIGTTIN， 后台进程尝试读操作
        SIGTTOU， 后台进程尝试写操作
    SIGCONT让进程恢复并继续执行（shell脚本通过它来控制作业），其余信号会使接收到的进程停止运行
    中断字符（Ctrl+C）向前台进程（当前正在运行的程序）发送SIGINT信号，这引起程序的终止，除非事先安排捕获这个信号
    使用kill向一个进程发送信号
    kill -HUP pid，向pid进程发送 挂断 信号
    kill命令的一个变体killall，可以给运行着某一命令的所有进程发送信号
    通知inetd程序重新读取它的配置选项，可以使用：killall -HUP inetd
    
    void (*signal(int sig, void (*func)(int)))(int);    //使用signal库函数处理信号（signal.h）
    上面函数定义说明，signal是一个带有sig和func两个参数的函数
    准备捕获或忽略的信号由sig给出，接收到指定信号后将要调用的函数由func给出
    信号处理函数必须有一个int类型的参数（即接收到的信号代码）并且返回类型为void
    signal函数本身也返回一个同类型的函数，即先前用来处理这个信号的函数
    可以代替信号处理函数的特殊值：
        SIG_IGN，忽略信号
        SIG_DFL，恢复默认行为
    (void) signal(SIGINT, function);    //捕获中断信号，使用function函数进行处理，function使用一个整数参数，它就是捕获的信号代码
    (void) signal(SIGINT, SIG_DFL);     //将中断信号的处理恢复为默认行为
    在信号处理函数中调用printf等函数是不安全的
    signal返回的是先前对指定信号进行处理的信号处理函数的函数指针，若未定义信号处理函数，则返回SIG_ERR并设置errno为一个正值，如果无效信号或不可捕获或不可忽略的信号，errno将被设置为EINVAL
    signal接口已经不推荐使用（老程序中还在），应该使用 sigaction函数
    
    发送信号：
        进程可以调用kill函数向包括它本身在内的其他进程发送一个信号
        如果程序没有发送该信号的权限，对kill函数的调用将失败，失败的常见原因是目标进程由另一个用户所拥有
        kill函数和shell中的kill命令完成相同的功能
        
        int kill(pid_t pid, int sig);   （sys/types.h， signal.h）
        kill函数把sig信号发送给pid对应的进程，成功返回0
        要发送信号，发送进程必须拥有相应的权限，即两个进程必须拥有相同的用户ID（只能发送给属于自己的进程，root用户可以发送信号给任可进程）
        kill调用失败返回-1并设置errno变量，失败原因可能是：
            信号无效（errno为EINVAL）、发送进程权限不够（errno为EPERM）、目标进程不存在（ESRCH）
        
        进程可以通过调用alarm函数在经过预定时间后发送一个SIGALRM信号（闹钟功能）
        unsigned int alarm(unsigned int seconds);
        在seconds秒之后安排发送一个SIGALRM信号，实际闹钟时间将比预先安排的要拖后一点（处理的延时和时间调度的不确定性）
        seconds设为0将取消所有已设置的闹钟请求
        在接收到SIGALRM信号之前再次调用alarm，则闹钟重新开始计时
        每个进程只能有一个闹钟时间，返回值是以前设置的闹钟时间的余留秒数，调用失败返回-1
    
        int pause(void);    （unistd.h）
        把程序的执行挂起直到有一个信号出现为止
        当程序接收到一个信号时，信号处理函数开始运行，程序也将恢复正常的执行
        当pause被一个信号中断时，返回-1并把errno设为EINTR
        当需要等待信号时，一个更常见的方法是 sigsuspend函数
        使用信号并挂起程序的执行是Linux程序设计中的一个重要部分，程序不需要循环检查某个事件是否已发生
        一些系统调用会因为接收到一个信号而失败
        竞态条件，如信号出现在pause之前，就会使程序无限期地等待一个不会发生的事件
    
    一个健壮的信号接口：
        X/Open规范和UNIX规范推荐：sigaction
        int sigaction(int sig, const struct sigaction *act, struct sigaction *oact); （signal.h）
        sigaction结构定义在signal.h中，作用是定义在接收到参数sig信号后应该采取的行动
        sigaction结构：
            void (*) (int) sa_handler，  function，SIG_DFL or SIG_IGN
            sigset_t sa_mask，   signals to block in sa_handler
            int sa_flags，       signal action modifiers
        sigaction函数设置与信号sig关联的动作，如果oact不是空指针，sigaction将把原先对该信号的动作写到它指向的位置
        如果act是空指针，则sigaction函数就不需要再做其他设置了，否则将在该参数中设置对指定信号的动作
        成功返回0，失败返回-1，errno将被设置，如 EINVAL
        sa_handler是一个函数指针，指向接收到信号sig时将被调用的信号处理函数，可以将其设置为SIG_IGN和SIG_DFL，同signal函数
        sa_mask指定一个信号集，在调用sa_handler的信号处理函数之前，该信号集将被加入到进程的信号屏蔽字中，这是一组将被阻塞且不会传递给该进程的信号
        设置信号屏蔽字可以防止信号在它的处理函数还未运行结束时就被接收到的情况，使用sa_mask可以消除这一竞态条件
        sigaction函数设置的信号处理函数在 默认情况下是不被重置的，若重置，必须在sa_flags中包含SA_RESETHAND
        信号处理函数的可重入问题，很重要，以及防止重入问题、中断等，信号在处理期间再次接收到信号时再次调用即为重入 ？
        信号处理函数正在执行时，新接收到的信号将在该处理函数的执行期间被添加到进程的信号屏蔽字中，这防止同一信号的不断出现引起信号处理函数的再次运行
        
    信号集：
        头文件定义了sigset_t和用来处理信号集的函数
        sigaction和其他函数将用这些信号集来修改进程在接收到信号时的行为
        
        int sigaddset(sigset_t *set, int signo);    //从信号集中增加给定的信号
        int sigemptyset(sigset_t *set);         //将信号集初始化为空
        int sigfillset(sigset_t *set);          //将信号集初始化为包含所有已定义的信号
        int sigdelset(sigset_t *set, int signo);    //从信号集中删除给定的信号
        成功返回0，失败返回-1并设置errno
        只定义了一个错误代码，是信号无效（EINVAL）
        
        int sigismember(sigset_t *set, int signo);  （signal.h）
        判断一个给定的信号是否是一个信号集的成员，是返回1，不是返回0，信号无效，返回-1并设置errno为EINVAL
        
        int sigprocmask(int how, const sigset_t *set, sigset_t *oset);
        进行信号屏蔽字的设置或检查工作，信号屏蔽字是指当前被阻塞的一组信号，它们不能被当前进程接收到
        根据how指定的方法修改进程的信号屏蔽字，新的信号屏蔽字由set指定（不能为空），原先的信号屏蔽字将保存到oset中
        how的取值：
            SIG_BLOCK， 把参数set中的信号添加到信号屏蔽字中
            SIG_SETMASK， 把信号屏蔽字设置为参数set中的信号
            SIG_UNBLOCK， 从信号屏蔽字中删除参数set中的信号
        set为空指针时，how的值无意义，此时的作用就是把当前的值保存到oset中
        成功返回0，how取值无效，将返回-1并设置errno为EINVAL
        
        一个信号被进程阻塞就不会传递给进程， 但会停留在待处理状态，可以通过sigpending函数查看进程阻塞的信号中有哪些正停留在待处理状态
        int sigpending(sigset_t *set);
        作用是将被阻塞的信号中停留在待处理状态的一组信号写到参数set指向的信号集中
        成功返回0，失败返回-1并设置errno以表明错误原因
        
        进程可以通过调用sigsuspend函数挂起自己的执行，直到信号集中的一个信号到达为止，pause函数类似
        int sigsuspend(const sigset_t *sigmask);
        将进程的屏蔽字替换为由sigmask给出的信号集，然后挂起程序的执行，程序将在信号处理函数执行完毕后继续执行
        如果接收到的信号终止了程序，sigsuspend就不会返回，如果信号没有终止程序，返回-1并将errno设置为EINTR
        
        sigaction标志：
            sigaction结构中的sa_flags字段的取值，用于改变信号的行为：
                SA_NOCLDSTOP， 子进程停止时不产生SIGCHLD信号（进程暂停，子进程终止时仍会产生SIGCHLD信号）
                SA_RESETHAND， 将对此信号的处理方式在信号处理函数的入口处重置为SIG_DFL
                SA_RESTART， 重启可中断的函数而不是给出EINTR错误
                SA_NODEFER， 捕获到信号时不将它添加到信号屏蔽字中
            当信号被捕获时，SA_RESETHAND可用来自动清除它的信号处理函数
            许多系统调用是可中断的，当接收到信号时它们将返回错误并设置errno为EINTR，表明函数因信号而返回
            sa_flags设置SA_RESTART标志，在信号处理函数执行完之后，函数将被重启而不是被信号中断
            可重入
            如果信号处理函数是一个不可重入函数，在它执行期间再次调用它就有可能引起问题
            可以在信号处理函数中安全调用的函数（X/Open规范保证都是可重入或本身不会再生成信号的）：
                access、alarm、chdir等等
                具体更多见 P414页
        
        常用信号参考：
            Linux和UNIX程序常用的信号及其默认行为
            默认动作都是异常终止进程，进程以_exit调用方式退出，但进程的结束状态会传递到wait和waitpid，从而表明进程是因某个信号而异常终止的：
                SIGALRM，    由alarm函数设置的定时器产生
                SIGHUP，     由一个处于非连接状态的终端发送给控制进程，或者由控制进程在自身结束时发送给每个前台进程
                SIGINT，     一般由从终端的Ctrl+C或预先设置好的中断字符产生
                SIGKILL，    shell中用来强制终止异常进程
                SIGPIPE，    向管道写数据时没有与之对应的读进程，就会产生
                SIGTERM，    要求进程结束运行，kill命令默认发送的信号
                SIGUSR1、SIGUSR2     进程间用这个信号进行通信，如让进程报告状态信息等
            
            引起进程的异常终止，可能会有一些与具体实现相关的其他动作，创建core文件等：
                SIGFPE，     由浮点运算异常产生
                SIGILL，     处理器执行了一条非法指令，  通常由奔溃的程序或无效的共享内存模块引起的
                SIGQUIT，    一般由Ctrl+\ 或预先设置好的退出字符产生
                SIGSEGV，    段冲突，对内存中的无效地址进行读写引起的，数组越界、解引用无效指针等
            
            进程被挂起：
                SIGSTOP，    停止执行（不能被捕获或忽略）
                SIGTSTP，    终端挂起信号，通常是Ctrl+Z 产生
                SIGTTIN、SIGTTOU     shell表明后台作业因需要从终端读取输入或产生输出而暂停运行
                
            重启被暂停的进程，若没有暂停则忽略：
                SIGCONT，    如果进程被暂停，就继续执行
                SIGCHLD，    子进程暂停或退出时产生，默认情况下被忽略
