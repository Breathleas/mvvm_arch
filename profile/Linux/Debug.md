
## DEBUG

    一般来说，每100行代码会有两个左右的错误
    错误类型
    常用调试技巧
    使用GDB和其他工具进行调试
    断言
    内存调试

#### 错误类型

    功能定义错误：
        确认并理解这个程序是用来干什么的，分析用户需求，加强和用户的沟通
    设计规划错误：
        提取确定，如何构造程序，需要什么样的数据结构，应该如何在程序中使用等
    代码编写错误：
        重新阅读源代码或与其他人进行探讨
    
    空运行（dry running）

#### 常用调试技巧

    代码检查-试运行-出错法：先运行并观察输出结果，不能正常工作再修改然后重新尝试
    取样法：在程序中增加一些语句来获得更多关于程序内部运行情况的信息
    受控执行法：直接检查程序的执行情况
    程序调试的阶段：
        测试，找出程序的缺陷或错误
        固化，让程序错误可重现
        定位，确定相关的代码行
        纠正，修改代码纠正错误
        验证，确定修改解决了问题
    
    有漏洞的程序：
        段错误（Segmentation fault），非法的内存访问，为防止内存空间被破坏，操作系统提前终止程序运行
        操作系统分配给程序的内存一般都会比程序实际需要使用的大一些，如果非法内存访问出现在这部分内存区域，硬件就可能检测不到，从而不会产生段错误
        分配给程序的内存大小会取整到操作系统的特定边界，一般分配的内存大小以8K为单位递增
        增加数组元素的大小，对不存在的数组元素进行访问时，内存地址就有可能落在分配给程序的内存之外的地方，从而产生段错误
    
    代码检查：
        编译器可以帮助完成代码检查工作
        gcc -Wall -pedantic -ansi，启用许多警告和其他检查来检验程序是否符合C语言标准
        lint、splint工具
    
    取样法：
        是指在程序中添加一些代码以收集更多与程序运行时的行为相关的信息的方法
        使用printf函数打印变量在运行时不同阶段的值
        两种取样法的技巧：
            1、用C语言的预处理器有选择地包括取样代码，只需重新编译程序就可以包含或去除调试代码
                #ifdef DEBUG
                    printf("xxx");
                #endif
               编译时加上编译器标志-DDEBUG，就定义了DEBUG符号，未加上该标志，这些调试代码将被删除
               数值调试宏：#define BASIC_DEBUG 1，#define EXTRA_DEBUG 2，#define SUPER_DEBUG 4
                #if (DEBUG & EXTRA_DEBUG)
                #endif
               此时，-DDEBUG=5将启用BASIC_DEBUG和SUPER_DEBUG，不包括EXTRA_DEBUG
               标志-DDEBUG=0将禁用所有调试信息
                #ifndef DEBUG
                #define DEBUG 0
                #endif
               此时，不需要调试时就不必在命令行上定义DEBUG宏
               C语言预处理器定义的一些宏（帮助调试）：
                    __LINE__，代表当前行号的十进制常数
                    __FILE__，代表当前文件名的字符串
                    __DATE__，代表当前日期，mmm dd yyyy格式的字符串
                    __TIME__，代表当前时间，hh:mm:ss格式的字符串
                    当前指的是运行编译器对文件进行处理时的时间和日期
            2、无需重新编译的调试技巧：
                在程序中增加一个作为调试标志的全局变量，可以在命令行上通过-d选项切换是否启用调试模式，即使程序已经发布，也可以调试
                 if(debug) {
                    sprintf(msg, ...);
                    write_debug(msg);
                 }
                使用标准错误输出或者 syslog 输出调试信息
                
    程序的受控执行：
        用调试器来控制程序的执行随时查看这些变量的状态
        调试器有：adb、sdb、idebug、dbx、gdb
        针对gdb的“前端”程序：xxgdb、KDbg、ddd
        编译时加上一个或多个特殊的编译器选项，让编译器在程序中添加额外的调试信息，包括各种符号和源代码行号
        -g标志，必须在编译每个需要调试的源文件时都加上这个选项，对链接器也要加上
        调试信息的加入使可执行程序的长度成倍增加（最高可达10倍）
        可执行程序容量增加（占用更多的磁盘空间），但程序运行时所需要的内存数量还是和原来一样
        程序调试结束后，最好将调试信息从程序的发行版本中删除
        strip <file>，命令将可执行文件中的调试信息删除而不需要重新编译程序

#### 使用gdb进行调试

    Linux中的默认调试器，能够用于调试嵌入式实时系统
    启动gdb：
        cc -g -o xxx xxx.c
        gdb xxx
        gdb的在线帮助，可以通过info程序或Emasc程序查阅
        空命令，直接按下回车键时会再次执行最近执行过的那条命令（step或next时非常有用）
        quit命令退出
    
    运行一个程序：
        启动gdb
        用run命令来执行程序，run命令中给出的参数作为程序的参数传递给程序
    栈跟踪：
        用backtrace命令查出程序如何到达在失败时所停的位置，打印调用栈
        backtrace可以简写为bt，where命令也可以用来完成相同的功能
    检查变量：
        gdb在停止程序时给出的信息以及从跟踪栈得到的信息可以看到函数参数的取值
        print命令，可以用调试器检查函数参数、局部变量和全局变量的内容，如：print j
        print给出变量和其他表达式的内容，gdb用伪变量保存类似这样的输出值以备后用，依次是：$1、$2、$3 ...
        print可以打印变量、数组元素和指针的取值，如：print a[3]
        gdb将命令的结果保存在伪变量$<number>中，最后一次操作的结果总是$，倒数第二次操作的结果为$$
        可以把某次操作的结果用在另一个命令中，如： print a[$-1]
    列出程序源代码：
        可以直接在gdb里用list命令列出程序的源代码
        list，会打印出围绕当前位置前后的一段代码，继续使用list，将显示更多
        给list命令提供一个行号或函数名作为参数，将显示指定位置前后的代码
    设置断点：
        用gdb对程序的运行做单步调试
        通过设置断点在任一位置停止程序的运行，将中断程序的运行并将控制权返回给调试器
        对变量进行检查并让程序从断点位置继续执行
        help breakpoint命令可以列出设置断点的命令
        break 21，在第21行设置一个断点
        run，然后运行程序
        cont命令，继续执行程序，直到遇到下一个断点，同一时间可以存在多个断点
        @<number>，让gdb打印出指定数目的数组元素，如：print a[0]@5
        display命令，告诉gdb在每次程序停在断点位置时自动显示，如自动显示数组的内容：display a[0]@5
        commands命令，指定在程序到达断点位置时需要执行的调试器命令，使程序不在断点处停下来，而只是执行命令后继续执行
        end命令，结束commands 命令的输入
    用调试器打补丁：
        通过将断点的设置与相应的操作结合起来，就可以尝试修改程序（打补丁）而不需要改变程序的源代码并重新编译
        info命令，查看曾经设置过的断点及display命令的内容
        info display
        info break
        disable break 1，禁用断点设置，可以在今后必要时重新启用这些保留的设置
        delete break 1，删除设置
        break 30，重新打断点
        commands 2，指定在第二个断点处需要执行的命令，会进入命令编译状态，如：
            commands 2
            >set variable n = n+1
            >cont
            >end    //结束命令编辑状态
            
    深入gdb：
        gdb可以提供许多与执行中的程序的内部状态有关的信息
        硬件断点是某些CPU提供的功能，这些处理器可以在触发某个特定条件时自动停止运行
        gdb在支持硬件断点功能的系统上，实时监控变量取值的变化情况
        gdb监控表达式，即当某个表达式取了一个特定值时，gdb可以暂停程序的运行
        断点可以和计数、条件结合在一起设置，只有在经过了指定的次数或满足某个条件时才触发断点
        gdb可以将其自身附在已经运行的程序上
        用gcc -O -g这样的命令来同时获得程序优化和调试信息的好处
        用gdb调试已经奔溃的程序，程序运行失败时，Linux会产生一个核心转储（core dump），并将它保存在core文件中
        core文件是程序的内存映像文件，包含程序在运行失败的那个时刻的全局变量的取值，可以用gdb找出程序发送奔溃的位置
        更多查阅gdb手册页

#### 其他调试工具

	提供关于程序的静态信息和提供动态分析的工具
	静态分析只能通过程序的源代码提供信息，工具有：
		ctags、cxref、cflow
		通过源文件提供有关函数调用和函数所在位置的有用信息
	动态分析提供的是与程序执行过程中的行为有关的信息，工具有：
		prof、gprof等
		提供的信息包括已经执行了哪些函数以及这些函数的执行时间

	lint：清理程序中的“垃圾”
		lint可以检测出未经赋值的变量使用、函数的参数未使用等情况
		类lint工具splint可以提供有用的代码审查注释
		splint -strict xxx.c，发现源代码问题
		
	函数调用工具：
		ctags、cxref、cflow
		ctags：
			ctags为程序中的所有函数创建索引，每个函数对应一个列表，在列表中列出该函数在程序中的调用位置，就像书籍中的索引
			ctags [-a] [-f filename] sourcefile sourcefile ...
			ctags -x sourcefile sourcefile ...
			默认，ctags在当前目录下创建文件tags，该文件包含每个输入源文件中声明的每个函数。文件格式为： announce xxx.c /^static void announce(void)/
			文件中每行由函数名、声明该函数的文件和一个可以用来在文件中查找该函数定义的正则表达式组成
			-x选项在标准输出上列出类似上面格式的内容
			-f选项将输出重定向到另一个不同的文件中，也可以用-a选项将输出结果附加到一个已有文件的结尾
		cxref：
			分析C语言源代码并生成一个交叉引用表，可以显示每个符号（变量、#define定义和函数）都在程序的哪个位置使用过
			生成的是一个经过排序的列表。每个符号的定义位置用一个星号做标记
			cxref *.c *.h
			具体使用参考手册页
		cflow：
			打印出一个函数调用树（function call tree），显示了函数之间调用的关系
			可以让我们看清楚一个程序的框架结构，理解它的操作流程，了解对某个函数的改动将会产生怎样的影响
			cflow -i，将产生一个反向的函数调用树，针对每个函数，cflow列出调用它的其他函数

	用prof/gprof产生执行存档：
		查找程序的性能问题时，一种常用的技巧是使用执行存档（execution profiling），通常需要特殊的编译器选项和辅助程序的支持
		程序的执行存档可以显示执行它所花费的时间具体都用在什么操作上了
		给编译器加上-p标志（针对prof）或-pg标志（针对gprof）就可以创建出profile程序
		prof（gprof）可以根据profile程序运行时所产生的执行跟踪文件打印出一个报告
		编译命令： cc -pg -o xxx xxx.c
		监控数据将被写入当前目录下的文件 mon.out（gprof用的是 gmon.out）
		prof/gprof程序读取监控数据并生成一个报告，使用参考手册页

#### 断言

	X/Open提供了assert宏，作用是测试某个假设是否成立，如果不成立就停止程序的运行
	void assert(int expression)	，（assert.h）
	assert宏对表达式进行求值，如果结果非0，就往标准错误写一些诊断信息，然后调用abort函数结束程序的运行
	assert.h定义的宏受NDEBUGG的影响，如果程序在处理这个头文件时已经定义了NDEBUG，就不定义assert宏
	可以在编译期间使用-DNDEBUGG关闭断言功能或将 #define NDEBUG 加到每个源文件中，且必须放在#include<assert.h>语句之前

#### 内存调试

	动态内存分配是一个很容易出现程序漏洞的领域，且一旦出现漏洞，还很难查找
	程序中使用malloc和free函数来分配内存，就必须清楚自己分配过的每一块内存，并且要确定没有使用已经释放的内存块
	内存块通常都是由malloc函数分配给指针变量的，如果指针变量的取值发生了变化，又没有其他指针指向这块内存，这块内存就变得无法访问，这就是一种内存泄露现象，它将导致程序的长度不断增加，系统越来越慢，最终耗尽内存
	如果在一个已分配的内存块尾部的后面（或头部前面）写数据，就很可能会损坏malloc库用于记录内存分配情况的数据结构，出现这种情况后，经过一段时间，一个malloc调用或free调用都会引发段错误并导致程序奔溃
	要想查出错误发生的准确地点是非常困难的，因为错误可能是在引发程序奔溃的事件之前很久发生的
	malloc、free的一些版本包含用于检查内存分配和内存释放情况，以解决诸如一个内存块被释放两次以及其他类型的误用

	ElectricFence函数库：
		尝试用linux的虚拟内存机制来保护malloc和free所使用的内存，当它发现内存被破坏时就停止程序的运行
		使用： cc -o xxx xxx.c -lefence
		只需将程序与ElectricFence函数库libefence.a链接起来，运行时就会收到响应
		cc -g -o xxx xxx.c -lefence
		gdb xxx	
		当程序运行出现问题时，可以结合gdb使用，通过run命令运行，定位出现问题的位置
		ElectricFence将malloc及其关联函数替换为使用计算机处理器虚拟内存机制的版本，从而保护系统不受非法内存访问的破坏，当出现这类的非法内存访问时，会引发一个段冲突信号并停止程序的运行

	valgrind：
		是一个工具，能检测出前面出现过的许多问题
		可以检测出数组访问错误和内存泄露
		程序不需要重新编译就可以使用valgrind，甚至可以用它来调试一个正在运行程序的内存访问情况
		使用： valgrind --leak-check=yes -v ./xxx
		用valgrind运行程序时，将看到它诊断出许多问题
		可以配合gdb在错误地点中断程序的运行
		valgrind有许多选项，包括对特定类型错误的抑制和内存泄露的检测
		要想检测程序的内存泄露问题，必须使用一个选项
		如果想在程序运行结束时进行内存泄露的检查，需要指定选项--leak-check=yes
		valgrind中途截获程序执行的各种操作并进行许多检查工作，包括内存访问的检查，如果该访问操作涉及一个已分配内存块并且是非法的访问，将打印出消息，程序执行结束时，它将运行一个垃圾收集例程来检测是否有已分配的内存块未被释放，如果有将报告这些被遗弃的内存块
		使用命令valgrind --help获得完整的选项列表