
## 信号量、共享内存和消息队列

	进程间通信的机制（IPC，Inter-Process Communication），最初由AT&T System V.2版本的UNIX引入
	System V IPC
	信号量：用于管理对资源的访问
	共享内存：用于在程序之间高效地共享数据
	消息队列：在程序之间传递数据的一种简单方法

#### 信号量

	临界代码，需要确保只有一个进程（或一个执行线程）可以进入这个临界代码并拥有对资源独占式的访问权
	临界区域，对数据库进行更新，真正执行数据更新的代码需要独占式地执行，它们被成为临界区域，通常在大型程序中占据一小段代码
	为防止出现因对个程序同时访问一个共享资源而引发的问题，在任一时刻只能有一个执行线程访问代码的临界区域
	线程中通过互斥量或信号量来控制对临界区域的访问
	硬件支持独占式访问（通过特定的CPU指令的形式），用一条指令以原子方式访问，在此期间不会有其他指令（甚至是一个中断）发生
	使用带O_EXCL标志的open函数来创建锁文件，它提供了原子化的文件创建方法，允许一个进程通过获取一个令牌（即新创建的文件）来取得成功，这个方法适合于简单的问题
	信号量的更正式的定义：它是一个特殊变量，只允许对它进行等待（wait）和发送信号（signal）这两种操作
		P（信号量变量）：用于等待；V（信号量变量）：用于发送信号
		传递，就好像位于进入临界区域之前的检查点；给予或释放，就好像放弃对临界区域的控制权

	信号量的定义：
		二进制信号量：只能取值0、1
		通用信号量：可以取多个正整数值的信号量
		PV操作（对信号量变量sv操作）的定义：
			P(sv)，如果sv的值大于0，就减1；如果等于0，就挂起该进程的执行
			V(sv)，如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而被挂起，就给它加1
		当临界区域可用时，信号量变量sv的值是true，然后P(sv)操作将它减1变为false以表示临界区域正在被使用；当进程离开临界区域时，使用V(sv)操作将它加1，使临界区域再次变为可用
		使用普通变量是不行的
		信号量操作很特殊，进程间操作

	一个理论性的例子：
		两个进程proc1和proc2，都需要在其执行过程中某一时刻对一个数据库进行独占式的访问，定义一个二进制信号量sv，初始值为1，两个进程都可以访问它，对代码中的临界区域进行访问，它们需要执行相同的处理步骤。
		两个进程共享sv，一旦其中一个进程执行P操作，它将得到信号量，可以进入临界区域；第二个进程将被阻止进入，因为当它执行P操作时，它将被挂起以等待第一个进程离开临界区域并执行V操作释放信号量
		伪代码：
		semaphore sv = 1;
		loop forever {
			P(sv);
			critical code section;
			V(sv);
			noncritical code section;
		}

	Linux的信号量机制：
		Linux信号量函数都是针对成组的通用信号量进行操作，而不是只针对一个二进制信号量
		int semctl(int sem_id, int sem_num, int command, ...);	(sys/sem.h)
		int semget(key_t key, int num_sems, int sem_flags);	(sys/sem.h)
		int semop(int sem_id, struct sembuf *sem_ops, size_t num_sem_ops);	(sys/sem.h)
		key的作用很像一个文件名，代表程序可能要使用的某个资源，如果多个程序使用相同的key值，它将负责协调工作
		semget函数返回的并用在其他共享内存函数中的标识符与fopen返回的FILE*文件流很相似，进程需要通过它来访问共享文件
		不同的进程可以用不同的信号量标识符来指向同一个信号量

		semget函数：
			作用是创建一个新信号量或取得一个已有信号量的键
			key是整数值，不相关的进程可以通过它访问同一个信号量
			程序对所用信号量的访问都是间接的，先提供一个键，再由系统生成一个相应的信号量标识符，只有semget函数才直接使用信号量键，所用其他的信号量函数都是使用由semget函数返回的信号量标识符
			特殊的信号量键值IPC_PRIVATE，作用是创建一个只有创建者进程才可以访问的信号量，很少用
			创建新的信号量时，需要给键提供一个唯一的非0整数
			num_sems参数指定需要的信号量数目，几乎总是取值为1
			sem_flags参数是一组标志，与open函数的标志类似，低端的9个比特是该信号量的权限，作用类似文件的访问权限，还可以和值IPC_CREAT做按位或操作，来创建新信号量
			可以通过联合使用标志IPC_CREAT和IPC_EXCL来确保创建出一个新的、唯一的信号量，如果该信号量已存在，将返回一个错误
			成功时返回一个正数值，就是其他信号量函数将用到的信号量标识符，失败返回-1

		semop函数：
			用于改变信号量的值
			sem_id是由semget返回的信号量标识符，sem_ops是指向一个结构数组的指针
			struct sembuf {
				short sem_num;	//是信号量编号，除非使用一组信号量，否则取值一般为0
				short sem_op;	//是信号量在一次操作中需要改变的数值（用非1的值改变信号量的值），通常只用两个值，-1 P操作，等待信号量变为可用，+1 V操作，发送信号表示信号量现在已可用
				short sem_flg;	//通常被设为SEM_UUNDO，将使OS跟踪当前进程对信号量的修改情况，如果该进程没有释放信号量的情况下终止，OS将自动释放该进程持有的信号量
			}
			使用非SEM_UNDO的值，就要注意保持设置的一致性，不能确保内核是否会在进程退出时清理信号量

		semctl函数：
			用来直接控制信号量信息
			sem_id由semget返回的信号量标识符
			sem_num是信号量编号，一般取值为0，表示唯一的一个信号量
			command是将要采取的动作
			第四个参数将会是一个union semun结构
			union semun {
				int val;
				struct semid_ds *buf;
				unsigned short *array;
			}
			command最常用的值：SETVAL 用来把信号量初始化为一个已知的值，这个值通过union semun中的val设置，其作用是在信号量第一次使用之前对它进行设置；IPC_RMID，用于删除一个已经无需继续使用的信号量标识符
			根据commandd的不同而返回不同的值，对于SETVAL和IPC_RMID，成功返回0，失败返回-1

	使用信号量：
		semget函数中的键（key）可以随意指定，IPC_CREAT 如果信号量不存在，就创建它
		srand、rand生成伪随机数
		信号量使用完毕后应及时删除，不删除信号量，它将继续在系统中存在，即使没有程序使用它，否则下次运行程序时会引发问题
		信号量也是一种有限的资源

#### 共享内存

	共享内存是3个IPC机制中的第二个，它允许两个不相关的进程访问同一个逻辑内存
	共享内存是两个正在运行的进程之间传递数据的一种非常有效的方式
	把由不同进程之间共享的内存安排为同一段物理内存
	共享内存是由IPC为进程创建的一个特殊的地址范围，它将出现在该进程的地址空间中
	其他进程可以将同一段共享内存链接到它们自己的地址空间中
	所有进程都可以访问共享内存中的地址，就像它们是由malloc分配的一样
	某个进程向共享内存写入数据，所做的改动将立刻被可以访问同一段共享内存的任何其他进程看到
	共享内存为在多个进程之间共享和传递数据提供了一种有效的方式
	共享内存未提供同步机制，需要用其他的机制来同步对共享内存的访问
	一般是用共享内存来提供对大块内存区域的有效访问，同时通过传递小消息来同步对该内存的访问
	对共享内存访问的同步控制必须由自己来负责，在第一个进程结束对共享内存的写操作前，并无自动的机制可以阻止第二个进程开始对它进行读取
	逻辑地址空间到可用物理内存的映射

	void *shmat(int shm_id, const void *shm_addr, int shmflg);		（sys/shm.h）
	int chmctl(int shm_id, int cmd, struct shmid_ds *buf);
	int shmdt(const void *shm_addr);
	int shmget(key_t key, size_t size, int shmflg);

	shmget函数：
		创建共享内存
		key，有效地为共享内存段命名
		返回一个共享内存标识符，用于后续的共享内存函数
		特殊的键值IPC_PRIVATE，用于创建一个只属于创建进程的共享内存，一些Linux中，私有的共享内存并不是真正的私有
		size以字节为单位指定需要共享的内存容量
		shmflg包含9个比特的权限标志，作用与创建文件使用的mode标志一样，由IPC_CREAT定义一个特殊比特必须和权限标志按位或才能创建一个新的共享内存段
		设置IPC_CREAT标志的同时，可以传递一个已有共享内存段的键，如果无需用到IPC标志，该标志就被忽略
		权限标志可以允许一个进程创建的共享内存可以被共享内存的创建者所拥有的进程写入，同时其他用户创建的进程只能读取该共享内存，以此可以提供一种对数据进行只读访问的方法
		成功返回一个非负整数，共享内存标识符，失败返回-1

	shmat函数：
		第一次创建共享内存段时，它不能被任何进程访问，要想启用对该共享内存的访问，必须将其连接到一个进程的地址空间中，由shmat完成
		shm_id是由shmget返回的共享内存标识符
		shm_addr指定的是共享内存连接到当前进程中的地址位置，通常是一个空指针，表示让系统来选择共享内存出现的地址
		shmflg是一组位标志，两个可能取值 SHM_RND（与shm_addr联合使用，用来控制共享内存连接的地址）、SHM_RDONLY（使得连接的内存只读）
		成功返回一个指向共享内存第一个字节的指针，失败返回-1
		共享内存的读写权限由属主（创建者）、它的访问权限和当前进程的属主决定，类似于文件的访问权限
		shmflg & SHM_RDONLY为true时，此时即使该共享内存的访问权限允许写操作，它都不能被写入

	shmdt函数：
		作用是将共享内存从当前进程中分离
		参数是shmat返回的地址指针，成功返回0，失败返回-1
		将共享内存分离并未删除它，只是使得该共享内存对当前进程不再可用

	shmctl函数：
		共享内存的控制函数
		struct shmid_ds {
			uid_t shm_perm.uid;
			uid_t shm_perm.gid;
			mode_t shm_perm.mode;
		}
		shm_id是shmget返回的共享内存标识符
		command是要采取的动作，可以取3个值：
			IPC_STAT，把shmid_ds结构中的数据设置为共享内存的当前关联值
			IPC_SET，如果进程有足够权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
			IPC_RMID，删除共享内存段
		buf是一个指针，指向包含共享内存模式和访问权限的结构
		成功返回0，失败返回-1
	删除一个正处于连接状态的共享内存段时，这个已经被删除的处于连接状态的共享内存段还能继续使用，直到从最后一个进程中分离为止，这个行为并未在X/Open规范中定义，最好不要依赖它

#### 消息队列

	第三个（最后一个）System V IPC机制：消息队列（message queue）
	消息队列与命名管道有相似之处，但少了打开和关闭管道方面的复杂性
	消息队列提供了一种在两个不相关的进程之间传递数据的相当简单且有效的方法
	它独立于发送和接收进程而存在，这消除了在同步命名管道的打开和关闭时可能产生的一些困难
	消息队列提供一种从一个进程向另一个进程发送一个数据块的方法，每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型值的数据块
	可以通过发送消息来几乎完全避免命名管道的同步和阻塞问题
	可以用一些方法来提前查看紧急消息
	与管道一样，每个数据块都有一个最大长度的限制，系统中所有队列所包含的全部数据块的总长度也有一个上限
	X/Open规范未提供发现这些限制的方法，只是告诉我们超过这些限制是引起一些消息队列函数失败的原因之一
	Linux的两个宏：MSGMAX和MSGMNB，以字节为单位分别定义一条消息的最大长度和一个队列的最大长度

	int msgctl(int msqid, int cmd, struct msqid_ds *buf);		（sys/msg.h）
	int msgget(key_t key, int msgflg);
	int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype,  int msgflg);
	int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);

	msgget函数：
		创建和访问一个消息队列
		key，键值来命名某个特定的消息队列
		特殊键值IPC_PRIVATE用于创建私有队列，应该只能被当前进程访问，但同信号量和共享内存一样，在某些Linux系统中事实上并非私有
		msgflg由9个权限标志组成，由IPC_CREAT定义的一个特殊位必须和权限标志按位或才能创建一个新的消息队列
		成功返回一个正整数，即队列标识符，失败返回-1

	msgsnd函数：
		用来把消息添加到消息队列中
		消息结构受两方面的约束，长度必须小于系统规定的上限，必须以一个长整型成员变量开始（接收函数将用这个成员变量来确定消息的类型）
		消息结构定义：
			struct my_message {
				long int message_type;
				/*data to transfer*/
			}
		必须声明自己的数据结构时包含message_type，并且最好初始化为一个已知值
		msqid是由msgget返回的消息队列标识符
		msg_ptr是一个指向准备发送消息的指针，消息必须以上面为准
		msg_sz是msg_ptr指向的消息的长度，这个长度不能包括长整型消息类型成员变量的长度
		msgflg控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情
		msgflg设置IPC_NOWAIT标志，函数将立刻返回，不发送消息并且返回值为-1，如果msgflg中的IPC_NOWAIT标志被清除，则发送进程将挂起以等待队列中腾出可用空间
		成功返回0，失败返回-1，若成功，消息数据的一份副本将被放到消息队列中

	msgrcv函数：
		从一个消息队列中获取消息
		msqid是由msgget返回的消息队列标识符
		msg_ptr是指向准备接收消息的指针，消息必须以一个长整型成员变量开始
		msg_sz是msg_ptr指向的消息的长度，不包括长整型消息类型成员变量的长度
		msgtype是一个长整数，可以实现一种简单形式的接收优先级，值为0，就获取队列中的第一个可用消息；值大于0，将获取具有相同消息类型的第一个消息；值小于0，将获取消息类型等于或小于msgtype的绝对值的第一个消息
		若只想按照消息发送的顺序来接收，就把msgtype设置为0，如果只想获取某一特定类型的消息，就把msgtype设置为相应的类型值，如果想接收类型等于或小于n的消息，就设置为-n
		msgflg用于控制当队列中没有相应类型的消息可以接收时将发生的事情，IPC_NOWAIT标志被设置，函数将立刻返回，返回值为-1，如果NOWAIT标志被清除，进程将会挂起以等待一条相应类型的消息到达
		成功返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中，然后删除消息队列中的对应消息，失败返回-1

	msgctl函数：
		作用与共享内存的控制函数非常类似
		msqid_ds结构：
		struct msqid_ds {
			uid_t msg_perm.uid;
			uid_t msg_perm.gid;
			mode_t msg_perm.mode;
		}
		msgid是由msgget返回的消息队列标识符
		command是将要采取的动作，可以取的值：
			IPC_STAT，把msqid_ds结构中的数据设置为消息队列的当前关联值
			IPC_SET，如果进程有足够的权限，就把消息队列的当前关联值设置为msqid_ds结构中给出的值
			IPC_RMID，删除消息队列
		成功返回0，失败返回-1，如果删除消息队列时，某个进程正在msgsnd或msgrcv中等待，这两个函数将失败

#### IPC的应用

	如果需要传递的消息非常小，可以直接使用消息队列来实现请求和响应的传递
	如果需要传递的数据量很大，可以考虑用共享内存来传递实际数据，再用信号量或消息来传递一个“令牌”去通知其他进程共享内存中的数据已可用
	消息队列允许一个进程往队列中放消息，即使这个进程是当前该队列的唯一用户
	通过消息中的消息ID域，就可以允许所用客户只使用一个队列，如PID把响应消息和特定的进程联系起来，进程可以只获取自己的消息，而将其他进程的消息留在队列中

#### IPC状态命令

	X/Open规范没有定义命令，大多数Linux系统都提供了一组命令，用于从命令行上访问IPC信息以及清理游离的IPC机制
	ipcs和ipcrm命令
	IPC机制的一个问题：异常终止的程序将把它的IPC资源（如消息队列中的数据）遗留在系统中，且这些资源在程序结束后很长时间仍然在系统中游荡，这将导致对程序的新调用执行失败，因为程序期望以一个干净的系统来启动，但事实上却发现一些遗留的资源
	状态命令（ipcs）和删除命令（ipcrm）提供了一种检查和清理IPC机制的方法

	显示信号量状态：
		ipcs -s，检查系统中信号量的状态
		可以用命令ipcrm来删除那些因意外而被程序遗留在系统中的信号量
		ipcrm -s 768（semid），删除信号量，老系统中使用 ipcrm sem 768

	显示共享内存状态：
		访问共享内存的细节情况
		ipcs -m，输出细节
		ipcrm -m <id>，或 ipcrm shm <id>，删除共享内存

	显示消息队列状态：
		ipcs -q、ipcrm -q <id>（或ipcrm msg <id>）
		ipcs -q，显示消息队列细节
		ipcrm -q <id>，用于删除一个消息队列
