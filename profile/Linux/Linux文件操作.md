
## Linux文件操作

#### Linux文件结构

    linux中，一切（或几乎一切）都是文件
    5个基本函数：open、close、read、write、ioctl
    linux中任何事物都可以用一个文件来表示，或者通过特殊文件提供
    
    一些特殊文件：
    目录：
        文件有内容、名字和一些属性（管理信息，包括文件的创建/修改日期和访问权限）
        文件的属性被保存在文件的inode（节点）中，一个特殊的数据块，还包含文件的长度和文件在磁盘上的存放位置
        系统使用的是文件的inode编号
        
        目录是用于保存其他文件的节点号和名字的文件
        目录文件中的每个数据项都是指向某个文件节点的链接，删除文件名就等于删除与之对应的链接
        ls -i，查看文件的节点号
        ln命令，在不同的目录中创建指向同一个文件的链接（）
        
        删除文件，实质上是删除该文件对应的目录项，同时指向该文件的链接数减1，该文件中的数据可能能通过其他指向同一文件的链接访问到
        指向某个文件的链接数变为0（ls -l查看），就表示该节点以及其指向的数据不再被使用，磁盘上的相应位置会被标记为可用空间
        
        ~user，进入其他用户家目录，标准库函数不认~，必须使用真实文件名
        /bin，存放系统程序（二进制可执行文件）
        /etc，存放系统配置文件
        /lib，存放系统函数库
        /dev，代表物理设备并为设备提供接口的文件
        /home，存放各个用户家目录

    文件和设备
        硬件设备通常也被映射为文件
        mount -t iso9660 /dev/hdc /mnt/cdrom，将ide CD-ROM驱动器挂载为一个文件
        接入系统的硬件会在/dev目录下生成一个文件，如上的hdc，硬盘等会有不同的名称
        使用mount命令，将硬件挂载到/mnt目录下，即可以文件形式访问硬件内容
        比较重要的设备文件：
            /dev/console：
                系统控制台，错误信息、诊断信息通常会被发送到这个设备，显示屏/终端接收控制台消息（打印终端等）
            /dev/tty：
                进程的控制终端（键盘、显示屏、窗口的别名），
                ls -R | more，显示长目录列表
                开多个tty，访问不同的物理设备
            /dev/null：
                空设备，写向这个设备的所有输出都将被丢弃，读这个设备会立刻返回一个文件尾标志，可用于创建空文件
                touch file
                cp /dev/null file，创建空文件
        设备被分为字符设备和块设备，区别在于访问设备时是否需要一次读写一整块
        块设备一般是那些支持某些类型文件系统的设备，如硬盘


#### 系统调用和设备驱动程序

    系统调用，用少量的函数就可以对文件和设备进行访问和控制，由UNIX直接提供
    内核是一组设备驱动程序，它们是一组对系统硬件进行控制的底层接口
    设备驱动程序封装了所有与硬件相关的特性，为用户提供一致的接口
    硬件的特有功能通常可通过ioctl（I/O控制）系统调用来提供
    用于访问设备驱动程序的底层函数（系统调用）：
        open，打开文件或设备
        read，从打开的文件或设备中读数据
        write，向文件或设备写数据
        close，关闭文件或设备
        ioctl，把控制信息传递给设备驱动程序
    每个驱动程序都有自己的一组ioctl命令
    系统调用的文档一般放在手册页的第二节

#### 库函数

    使用系统调用会影响系统的性能，比函数调用的开销要大些（会从用户态切换到内核态，然后再返回用户代码）
    每次的系统调用尽可能完成更多的工作，如：每次读取大量的数据而不是一个字符
    硬件会限制对底层系统调用一次所能读写的数据块大小
    
    标准库函数：
        由函数构成的集合
        可认为是对系统调用的封装，更高层的接口
        库函数文档一般放在手册页的第三节
    
      用户程序    |     <--用户空间
    库           |
    -------------
        || 调用
        \/        
     系统调用        |
    ----------------|  <--内核空间
    设备驱动程序| 内核|   
        ||
        \/    
      硬件设备

#### 底层文件访问

    进程 process，有一些与之关联的文件描述符，是一些小值整数，可以通过它们访问打开的文件或设备
    文件描述符的数量取决于系统配置
    一个程序开始运行时，一般会有3个已经打开的文件描述符：
        0：标准输入； 1：标准输出； 2：标准错误；
    使用自动打开的文件描述符就可以通过write系统调用来创建一些简单的程序
    
    write系统调用：
        把缓冲区buf的前nbytes个字节写入与文件描述符fildes关联的文件中，返回实际写入的字节数，0 未写入，-1 write出错，错误代码保存在全局变量errno
        size_t write(int fildes, const void *buf, size_t nbytes);   （头文件：unistd.h）
        fildes 为 0、1、2时，表示把数据写入到标准输入、输出、错误中
        write写入的字节可能比要求的少，要检查errno以发现错误，然后再次调用write写入剩余数据
    
    read系统调用：
        从与文件描述符fildes关联的文件中读入nbytes个字节数据放到缓冲区buf中，返回实际读入的字节数（可能会小于请求的字节数），0 未读入，-1 read出错，错误代码保存在全局变量errno
        size_t read(int fildes, void *buf, size_t nbytes);  （头文件：unistd.h）
        fildes 可以为 0、1、2，如：把标准输入复制到标准输出等

    open系统调用：
        创建一个新的文件描述符，建立一条到文件或设备的访问路径
        int open(const char *path, int oflags);     （头文件：fcntl.h、sys/types.h、sys/stat.h）
        int open(const char *path, int oflags, mode_t mode);
        返回一个可以被read、write、其他系统调用使用的文件描述符（非负整数），是唯一的，不会与运行中的其他进程共享
        两个程序同时打开一个文件，会分别得到两个不同的文件描述符，都作写操作时，它们会各写各的，数据不会交织在一起，而是彼此互相覆盖，可以使用文件锁功能来防止出现冲突
        path，为文件或设备名称
        oflags，用于指定打开文件所采取的动作
        oflags是通过命令文件访问模式与其他可选模式相结合的方式来指定的：
            O_RDONLY，以只读方式打开
            O_WRONLY，以只写方式打开
            O_WDWR，  以读写方式打开
        oflags参数的可选模式（“按位或”操作）：
            O_APPEND，写入数据追加在文件末尾
            O_TRUNC， 把文件长度设置为0，丢弃已有内容
            O_CREAT， 如果需要，按参数mode中给出的访问模式创建文件
            O_EXCL，  与O_CREAT一起使用，确保调用者创建出文件，open调用是原子操作，只执行一个函数调用，使用这个可选模式可以防止两个程序同时创建同一个文件，如果文件已存在，open调用将失败
        open失败时返回-1，并设置全局变量errno来指明失败的原因
        类似函数creat调用，相当于以oflags标志 O_CREAT|O_WRONLY|O_TRUNC来调用open，创建并打开文件
        一个进程可同时打开的文件数的限制在 limits.h 头文件中的OPEN_MAX定义的，其值至少为16，linux中这个限制可在运行时调整，通常开始为256
        
    访问权限的初始值：
        使用O_CREAT标志的open调用，必须使用mode（按位或）：
            S_IRUSR，读权限，文件属主（头文件：sys/stat.h）
            S_IWUSR，写权限，文件属主
            S_IXUSR，执行权限，文件属主
            S_IRGRP，读权限，文件属组
            S_IWGRP，写权限，文件属组
            S_IXGRP，执行权限，文件属组
            S_IROTH，读权限，其他用户
            S_IWOTH，写权限，其他用户
            S_IXOTH，执行权限，其他用户
        open("myfile", O_CREAT, S_IRUSR|S_IXOTH); //文件属主有读权限，other有执行权限，且只有这两个权限
        创建的文件权限会被用户掩码（shell的umask命令设定）影响，mode与umask的反值做AND操作，即open发出设置权限请求，是否会被设置取决于当时的umask
        umask：
            是一个系统变量，作用是：文件被创建时，为文件的访问权限设定一个掩码
            umask命令可修改这个变量的值，是由3个八进制数字组成的值，每个数字都是八进制1、2、4的OR操作结果
            3个数字分别对应 用户（user）、组（group）、其他用户（other），类似 755、 777这些权限设置
            0：允许任何权限；4：禁止读权限；2：禁止写权限；1：禁止执行权限
            eg：禁止组的写、执行权限，other的写权限， u：0， g：2 1， o：2
                u g o 的取值OR，即 group 2|1 为 3，最终umask值为：032
            在mode中被设置的位如果在umask中也被设置了，那么它就会从文件的访问权限中删除
            umask不能阻止 chmod命令（或者在程序中执行chmod系统调用）修改权限
    
        close系统调用：
            终止文件描述符fildes与其对应文件之间的关联
            文件描述符被释放并能够重新使用
            close成功返回0，出错返回-1
            int close(int fildes);  （unistd.h）
            检查close调用的返回结果，有的文件系统不会在关闭文件之前报告写操作中出现的错误，是因为执行写操作时数据可能未被确认写入
            
        ioctl系统调用：
            提供了一个用于控制设备及其描述符行为和配置底层服务的接口
            终端、文件描述符、socket等都可以有为它们定义的ioctl
            int ioctl(int fildes, int cmd, ...);    （unistd.h）
            对描述符fildes引用的对象执行cmd参数中给出的操作
            ioctl(tty_fd, KDSETLED, LED_NUM|LED_CAP|LED_SCR);   //linux上打开键盘上的LED灯
    
    其他与文件管理有关的系统调用：
        lseek系统调用：
            对文件描述符fildes的读写指针进行设置，即用它设置文件的下一个读写位置
            读写指针即可被设置为文件中的某个绝对位置，也可设置为相对于当前位置或文件尾的某个相对位置
            off_t lseek(int fildes, off_t offset, int whence);  （unistd.h）
            offset 指定位置，whence 定义该偏移值的用法
            whence的取值：
                SEEK_SET，offset是绝对位置
                SEEK_CUR，offset是相对于当前位置的一个相对位置
                SEEK_END，offset是相对于文件尾的一个相对位置
            返回值是从文件头到文件指针被设置处的字节偏移值，失败返回-1， off_t 整数类型，定义在 sys/types.h
        
        fstat、stat和lstat系统调用：
            fstat返回与打开的文件描述符相关的文件的状态信息，该信息写到buf中，buf的地址以参数形式传递给fstat
            int fstat(int fildes, struct stat *buf);
            int stat(const char *path, struct stat *buf);
            int lstat(const char *path, struct stat *buf);  （unistd.h、sys/types.h、sys/stat.h）
            stat、lstat返回的是通过文件名查到的状态信息，结果相同
            当文件是符号链接时，lstat返回的是该符号链接本身的信息，stat返回的是链接指向的文件的信息
            stat结构：
                st_mode，文件权限和文件类型信息
                st_ino，与该文件关联的inode
                st_dev，保存文件的设备
                st_uid，文件属主的UID号
                st_gid，文件属主的GID号
                st_atime，文件上一次被访问的时间
                st_ctime，文件的权限、属主、组或内容上一次被改变的时间
                st_mtime，文件的内容上一次被修改的时间
                st_nlink，该文件上硬链接的个数
            st_mode标志关联的宏：对访问权限、文件类型标志、权限的掩码、帮助测试特定类型等的定义
                访问权限标志与open系统调用中的内容一样
                文件类型标志：
                    S_IFBLK，文件是一个特殊的块设备
                    S_IFDIR，文件是一个目录
                    S_IFCHR，文件是一个特殊的字符设备
                    S_IFIFO，文件是一个FIFO（命名管道？）
                    S_IFREG，文件是一个普通文件
                    S_IFLNK，文件是一个符号链接
                其他模式标志：
                    S_IFUID，文件设置了SUID位
                    S_IFGID，文件设置了SGID位
                解释st_mode标志的掩码：
                    S_IFMT，文件类型
                    S_IRWXU，属主的读写执行权限
                    S_IRWXG，属组的读写执行权限
                    S_IRWXO，其他用户的读写执行权限
                帮助确定文件类型的宏定义（对经过掩码处理的模式标志和相应的设备类型标志进行比较）：
                    S_ISBLK，测试是否是特殊的块设备文件
                    S_ISCHR，测试是否是特殊的字符设备文件
                    S_ISDIR，测试是否是目录
                    S_ISFIFO，测试是否是FIFO
                    S_ISREG，测试是否是普通文件
                    S_ISLNK，测试是否是符号链接
            测试一个文件不是一个目录，设置了属主的执行权限，并且没有其他权限
            stat("filename", &statbuf);
            modes = statbuf.st_mode;
            if(!S_ISDIR(modes) && (modes & S_IRWXU) == S_IXUSR) ...
            
        dup和dup2系统调用：
            dup提供了一种复制文件描述符的方法，使能够通过两个或更多不同的描述符来访问同一个文件
            可以用于在文件的不同位置对数据进行读写
            dup 复制文件描述符返回新的描述符
            dup2 通过指定目标描述符来把文件描述符复制为另外一个
            int dup(int fildes);
            int dup2(int fildes, int fildes2);

#### 标准 I/O库

    标准IO库及其头文件stdio.h为底层I/O系统调用提供了一个通用的接口，ANSI标准C的一部分
