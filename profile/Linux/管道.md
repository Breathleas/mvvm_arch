
## 进程间通信：管道

    使用信号在两个进程间通信：创建通知事件--引起响应（传送的信息只限于一个信号值）
    管道（进程之间交换更有用的数据）：
        管道的定义
        进程管道
        管道调用
        父进程和子进程
        命名管道：FIFO
        客户/服务器架构

#### 什么是管道

    从一个进程连接数据流到另一个进程时，使用术语 管道（pipe），通常是把一个进程的输出通过管道连接到另一个进程的输入
    shell命令的管道字符：cmd1 | cmd2，实际上就是把一个进程的输出直接传递给另一个进程的输入
    cmd1的标准输入来自终端，cmd1的标准输出传递给cmd2，作为它的输入，cmd2的标准输出连接到终端

#### 进程管道

    FILE *popen(const char *command, const char *open_mode);
    int pclose(FILE *stream_to_close);      （stdio.h）
    popen允许一个程序将另一个程序作为新进程来启动，并可以传递数据给它或者通过它接收数据
    command是要运行的程序名和相应的参数，open_mode必须是 r 或  w
    r：被调用程序的输出可以被调用程序使用，调用程序利用FILE文件流指针，通过stdio库函数（fread等）读取被调用程序的输出
    w：调用程序可以用fwrite调用向被调用程序发送数据，而被调用程序可以在自己的标准输入（stdin）上读取这些数据
    被调用程序通常不会意识到自己正在从另一个进程读取数据，它只是在标准输入（stdin）流上读取数据，然后做出相应操作
    popen必须指定 r 或 w之一，失败返回空指针，要通过管道实现双向通信，可以使用两个管道
    
    pclose，用poen启动的进程结束时，用来关闭与之关联的文件流
    pclose调用只在popen启动的进程结束后才返回，如果调用pclose时它仍在运行，pclose调用将等待该进程的结束
    pclose的返回值通常是它所关闭的文件流所在进程的退出码
    如果调用进程在调用pclose前执行wait语句，被调用进程的退出状态就会丢失，因为被调用进程已结束，此时pclose返回-1并设置errno为ECHILD

#### 将输出送往popen

    od命令：八进制输出
    
    传递更多的数据：
        以块方式发送数据
        用多个fread、fwrite调用来将数据分为几部分处理
        读进程没有数据可读，它将被挂起直到有数据到达
        写进程产生的输出超过可以缓冲区的长度，它也会被挂起直到读进程读取了一些数据
    
    如何实现popen：
        popen调用运行一个程序时，它首先启动shell（系统中的sh命令），然后将command字符串作为一个参数传递给它
        在Linux（类UNIX）中，所有的参数扩展都是由shell来完成的，启动程序前先启动shell来分析命令字符串，就可以使各种shell扩展（如*.c所指的是哪些文件）在程序启动之前就全部完成
        其他创建进程的函数（execl等）必须自己去完成shell扩展，非常复杂
        针对每个popen调用，不仅要启动一个被请求的程序，还要启动一个shell，每个popen调用将多启动两个进程，调用成本略高，对目标命令的调用比正常方式要慢一些
        shell扩展：如*.c，将被扩展为一个文件列表， |，处理管道符，将前者的输出传递给后面
    
#### pipe调用

    int pipe(int file_descriptor[2]);   （unistd.h）
    底层调用，不需要启动一个shell来解释请求的命令，提供了对读写数据的更多控制
    参数是一个由两个整数类型的文件描述符组成的数组的指针
    该函数在数组中填上两个新的文件描述符后返回0，失败则返回-1并设置errno表明失败原因
    错误类型（Linux手册页第二部分定义）：
        EMFILE，进程使用的文件描述符过多
        ENFILE，系统的文件表已满
        EFAULT，文件描述符无效
    file_descriptor[0]读数据，file_descriptor[1]写数据
    两个返回的文件描述符以一种特殊的方式连接，写到file_descriptor[1]的所有数据都可以从file_descriptor[0]读回来
    数据基于先进先出（FIFO）进行处理
    栈 先进后出（LIFO）
    底层调用，文件描述符不是文件流，使用底层的read、write来访问数据，而不是文件流库函数fread和fwrite
    管道有一些内置的缓存区，在write和read调用之间保存数据
    
    fork调用创建新进程，原先打开的文件描述符仍将保持打开状态
    如果在原先的进程中创建一个管道，然后调用fork创建新进程，即可通过管道在两个进程之间传递数据
    用file_descriptor[0]写数据或file_descriptor[1]读数据，其后果将不可控，调用失败返回-1 或其他

#### 父进程和子进程

    使用exec调用在子进程中运行一个与父进程完全不同的另外一个程序
    经过exec调用后，原先的进程已经被新的子进程替换了，可以将文件描述符（pipe使用）作为一个参数传递给用exec启动的程序
    管道关闭后的读操作：
        循环读取数据时，当没有数据可读时，read调用通常会阻塞，即它将暂停进程来等待直到有数据到达为止
        如果管道另一端已被关闭，没有进程打开管道并向它写数据了，对一个已关闭写数据的管道做read调用将返回0而不是阻塞
        read把无效的文件描述符看作一个错误并返回-1
        跨越fork调用使用管道，就有两个不同的文件描述符可以用于向管道写数据，一个在父进程，一个在子进程，
        只有把两个文件描述符都关闭，管道才会被认为是关闭了，对管道的read调用才会失效
    
    把管道用作标准输入和标准输出：
        用管道连接两个进程，把其中一个管道文件描述符设置为一个已知值，一般是标准输入0或标准输出1
        调用标准程序，即那些不需要以文件描述符为参数的程序
        
        int dup(int file_descriptor);
        int dup2(int file_descriptor_one, int file_descriptor_two);     （unistd.h）
        dup调用打开一个新的文件描述符，创建的新文件描述符与作为它的参数的已有文件描述符指向同一个文件（或管道）
        新的文件描述符总是取最小的可用值
        
        dup2所创建的新文件描述符或者与file_descriptor_two相同，或者是第一个大于该参数的可用值
        fcntl调用（command参数设为F_DUPFD）也可达到与调用dup、dup2相同的效果，但dup调用更普遍，易于使用
        
        先关闭文件描述符0然后调用dup，新的文件描述符就将是数字0，因为新的文件描述符是复制一个已有的文件描述符，所以标准输入就会改为指向一个传递给dup的文件描述符对应的文件或管道
        此创建了两个文件描述符，它们指向同一个文件或管道，而且其中之一是标准输入
        
        用close和dup函数对文件描述符进行处理：
            文件描述符   初始值     关闭文件描述符0后   dup调用后
                0       标准输入        已关闭         管道文件描述符
                1       标准输出        标准输出        标准输出
                2       标准错误输出    标准错误输出     标准错误输出
                3       管道文件描述符   管道文件描述符   管道文件描述符

#### 命名管道：FIFO

    以上都是在相关的程序之间传递数据，即它们都是由一个共同的祖先进程启动的
    在不相关的进程之间交换数据
    FIFO文件也被称为命名管道（named pipe）
    命名管道是一种特殊类型的文件，在文件系统中以文件名的形式存在，但其行为和没有名字的管道类似
    可在命令行上创建命令管道： 
        mknod filename p
        mkfifo filename
    程序中的函数调用：
        int mkfifo(const char *filename, mode_t mode);      （sys/types.h，sys/stat.h）
        int mknod(const char *filename, mode_t mode | S_IFIFO, (dev_t) 0);
        与mknod命令一样，可以用mknod函数建立许多特殊类型文件
        用mknod函数创建命名管道，唯一具有可移植性的方法是 使用dev_t类型的值0，将文件访问模式与S_IFIFO按位或
        mode_t 文件访问模式
        文件模式会被用户掩码（umask）设置给改变，并不一定会得到预期结果
    ls -lF，查看输出结果，第一个字符p，表示是一个管道，最后的|符号由-F选项添加的，也表示是一个管道
    rm命令 或 unlink系统调用来删除FIFO文件
    
    访问FIFO文件：
        命令管道可以像平常的文件名一样在命令中使用
        cat < fifofile，被挂起，等待数据出现在FIFO中
        echo "text" > fifofile，在另一个终端中执行
        cat < fifofile &，后台执行
        echo "text" > fifofile，写数据
        
        FIFO以命名文件的形式存在，可以用open、close函数打开关闭
        传递给open调用的是FIFO路径名，而不是一个正常的文件
        
        使用open打开FIFO文件：
            不能以O_RDWR模式打开FIFO文件进行读写操作，这样做的后果未明确定义
            以读/写方式打开，进程就会从管道读回自己的输出
            程序间双向传递数据，最好使用一对FIFO或管道
            与打开普通文件的一点区别：open_flag的O_NONBLOCK选项，使用这个选项不仅改变open调用的处理方式，还会改变对这次open调用返回的文件描述符进行读写请求的处理方式
            O_RDONLY、O_WRONLY和O_NONBLOCK标志共有4种组合方式
            open(const char *path, O_RDONLY);   //open调用将阻塞，除非有一个进程以写方式打开同一个FIFO，否则不会返回
            open(const char *path, O_RDONLY | O_NONBLOCK);  //即使没有其他进程以写方式打开FIFO，这个open调用也将成功并立刻返回
            open(const char *path, O_WRONLY);   //open调用将阻塞，直到一个进程以读方式打开同一个FIFO为止
            open(const char *path, O_WRONLY | O_NONBLOCK);  //总是立刻返回，但如果没有进程以读方式打开FIFO文件，open调用将返回一个错误-1并且FIFO也不会被打开
            如果没有进程以读方式打开管道，非阻塞写方式的open调用将失败，但非阻塞读方式的open调用总是成功
            close调用的行为不受O_NONBLOCK标志影响
            access(filename, F_Ok)，检查文件是否存在
            
        命名管道允许先启动读进程，并在open调用中等待，当第二个程序打开FIFO时，两个程序继续运行，读进程和写进程在open调用处取得同步
        当一个Linux进程被阻塞时，并不消耗CPU资源，所以这种阻塞进程的同步方式非常有效率

        O_RDONLY | O_NONBLOCK，读进程执行open调用立刻继续执行，即使没有写进程存在
        
        对FIFO进行读写操作：
            使用O_NONBLOCK模式会影响到对FIFO的read和write调用
            对一个空的、阻塞的FIFO（不用O_NONBLOCK）的read调用将等待，直到有数据可以读时才继续执行
            对一个空的、非阻塞的FIFO（用O_NONBLOCK）的read调用将立刻返回0字节
            对一个满的、阻塞的FIFO（不用O_NONBLOCK）的write调用将等待，直到有数据可以被写入时才继续执行，
               如果FIFO不能接收所有写入的数据，将按下面规则执行：
                    如果请求写入的数据的长度小于等于PIPE_BUF字节，调用失败，数据不能写入
                    如果请求写入的数据长度大于PIPE_BUF字节，将写入部分数据，返回实际写入的字节数，返回值可能是0
               系统对任一时刻在FIFO中可以存在的数据长度是有限制的，由#define PIPE_BUF语句定义（limits.h），通常是4096字节
               系统规定：以O_WRONLY（阻塞）打开的FIFO中，如果写入的数据长度小于等于PIPE_BUF，要么写入全部字节，要么一个字节都不写入
               每个写操作必须原子化
            多个写进程同时写数据，保证不同程序的数据块不相互交错：
                能保证所有的写请求是发往一个阻塞的FIFO，并且每个写请求的数据长度小于等于PIPE_BUF字节，系统就可以确保数据块绝不会交错在一起
                通常将每次通过FIFO传递的数据长度限制为PIPE_BUF字节是个好办法，除非只使用一个写进程和一个读进程
            
            使用阻塞模式的FIFO，先启动写进程，它将阻塞以等待读进程打开FIFO
            读进程启动后，写进程解除阻塞并开始向管道写数据，同时读进程开始从管道中读取数据
            写进程在管道满时阻塞，读进程将在管道空时阻塞
            
    高级主题：使用FIFO的客户/服务器应用程序
        数据分块--长度小于PIPE_BUF字节
        以阻塞模式打开FIFO
        两个管道实现双向通信
        使用进程标识符（PID）为返回数据的管道生成一个唯一的名字
        使服务器持续等待客户连接的两种方式：
            Server对自己的服务器管道打开一个文件描述符，这样read调用将总是阻塞而不是返回0
            当read调用返回0时，关闭并重新打开服务器管道，使服务器进程阻塞在open调用处以等待客户的到来
    
    文件描述符是一种有限资源，应该只在需要时才打开一个管道
    在客户端以读写两种方式打开管道，用来防止一个竞争条件的出现，这个竞争条件会在服务器需要响应来自同一个客户的快速、连续的多个请求时发生