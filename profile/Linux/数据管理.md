
## 数据管理

    资源分配的管理方式   -- 动态内存管理
    多用户同时访问文件的处理    -- 文件锁定
    dbm数据库--不基于SQL的数据库函数库

#### 内存管理

    Linux程序不允许直接访问物理内存
    可直接寻址的内存空间
    内存保护机制
    交换空间
    
    简单的内存分配：
        void *malloc(size_t size);  （stdlib.h）
        标准C语言函数库，分配内存，size不是一个简单的整型
        旧式的DOS下的程序不能访问超过640K内存映射限制的内存范围
        size单位为byte，返回值需要转换为需要的类型，malloc保证返回的内存是地址对齐的，所以它可以被转换为任何类型的指针
        指针有32位、64位，32位指针可寻址的地址空间可达4GB
        
    分配大量的内存：
        malloc可分配大量内存，接近或大于物理内存，越接近物理内存大小，分配速度越慢
        malloc调用失败时，程序可能只是退出而不输出任何内容
        Linux内核管理内存分配，读写、请求内存都会由内核接管并决定如何处理
        刚开始时，内核使用空闲的物理内存来处理内存请求，当物理内存耗尽，便会使用交换空间（swap space）
        交换空间是安装系统时分配的独立的磁盘区域，内核会在物理内存和交换空间之间移动数据和程序代码
        Linux实现的是按需换页的虚拟内存系统，用户程序看到的是虚拟内存，不真正存在于物理地址上
        Linux将内存以页为单位进行划分，通常每一页大小为4096字节，当程序访问内存时，就会发生虚拟内存到物理内存的转换
        当访问的内存在物理上不存在时，就会产生一个页面错误并将控制权交给内核
        
        Linux内存会检查访问的内存地址，如果地址对于程序是合法可用的，内核就会确定需要向程序提供哪一个物理内存页面。
        如果该页面之前从未被写入过，内核就直接分配它，如果它已经被保存在硬盘的交换空间上，内核就读取包含数据的内存页面到物理内存（可能需要把一个已有页面从内存移出到硬盘），
        接着完成虚拟内存地址到物理地址的映射之后，内核允许用户程序继续运行
        当应用程序耗尽所有物理内存和交换空间，或者当最大栈长度被超过时，内核将拒绝此后的内存请求，并可能终止程序运行
        
        对malloc的返回值不检查可能出现的问题是：试图在一个已分配的内存块之后写数据，这可能会覆盖malloc库例程内部使用的一些数据，导致后续的malloc调用失败，是因为内存的结构已经被破坏（这些问题越早检测越好）
        
    滥用内存：
        Linux内存管理系统能保护系统的其他部分免受内存滥用的影响
        为确保一个行为恶劣的程序无法破坏任何其他程序，Linux会终止其运行
        每个在Linux系统中运行的程序都只能看到属于自己的内存映像，不同的程序看到的内存映像不同
        只有操作系统知道物理内存是如何安排的，不仅为用户程序管理内存，同时也为用户程序提供彼此之间的隔离保护
    
    空指针：
        Linux对空指针指向的地址的读写提供了很强的保护
        printf可以打印一个取自空指针的字符串，打印(null) \0（GNU C函数库容忍读操作），魔术字符串
        向一个空指针里写数据，直接终止程序，Segmentation fault
        不使用GNU libc库，直接从零地址处读取数据，程序终止，段错误
    
    释放内存：
        Linux内存管理系统能保证在程序结束时，把分配给程序的内存返回给系统
        动态使用内存的程序应该通过free调用来把不用的内存释放给malloc内存管理器，这样可以把分散的内存块重新合并到一起
        如果一个进程自己使用并释放内存，这些自由内存实际上仍然处于被分配给该进程的状态
        Linux将程序使用的内存块作为一个物理页面集来管理，通常内存中的每个页面为4K字节
        如果一个内存页面未被使用，内存管理器就将其从物理内存置换到交换空间中（叫换页），从而减轻它对资源使用的影响
        如果程序试图访问位于已置换到交换空间中的内存页中的数据，Linux会短暂暂停程序，将内存页从交换空间再次置换到物理内存，然后程序继续运行，就像数据一直存在于内存中一样
        
        void free(void *ptr_to_memory);     （stdlib.h）
        free使用的指针参数必须是指向由malloc、calloc或realloc调用所分配的内存
        free释放一块内存后，它就不再属于这个进程，将由malloc函数库负责管理
        free后，就决不能再对其进行读写操作
    
    其他内存分配函数：
        void *calloc(size_t number_of_elements, size_t element_size);
        void *realloc(void *existing_memory, size_t new_size);  （stdlib.h）
        calloc的作用是为一个结构数组分配内存，元素个数、每个元素的大小，分配的内存全部初始化为0
        calloc调用成功，返回指向数组中第一个元素的指针
        两次调用calloc分配的内存无法保证是一个连续的内存空间，不同通过这种方式扩大数组
        
        realloc用来改变先前已经分配的内存块的长度，增加或减少malloc或calloc或realloc分配的内存指针的长度
        realloc可能会移动数据，必须在分配成功后使用新的指针
        realloc无法调整内存块大小，会返回一个null指针，所以不能使用先前的指针指向realloc
        配合memcpy使用，备份数据，防止null指针找不到数据的情况

#### 文件锁定

    文件锁定是多用户、多任务操作系统中一个非常重要的组成部分
    通常同过文件来实现程序间的共享数据
    Linux实现文件锁定的特性有：
        1、以原子操作的方式创建文件，原子操作就是在创建文件时，系统将不允许任何其他的事情发生，确保文件唯一，且不可能被其他程序同一时刻创建
        2、允许程序锁定文件的一部分，从而可以独享对这一部分内存的访问，有两种方式可以实现2
    
    创建锁文件：
        针对某个资源创建一个锁文件，其他程序就可以通过检查这个文件来判断它们自己是否被允许访问这个资源
        锁文件通常被放置在一个特定位置，带有一个与被控制资源相关的文件名，如：调制解调器被使用，会在/var/spool目录下创建一个锁文件
        锁文件仅仅只是充当一个指示器的角色，程序间需要相互协作来使用它们
        锁文件只是建议锁，而不是强制锁，后者，系统将强制锁的行为
        使用fcntl.h中的open系统调用，带上O_CREAT和O_EXCL标志，创建锁文件，以一个原子操作同时完成两项工作
        O_EXCL标志，如果文件存在会调用失败，出错，所以必须在使用完毕之后删除文件
        错误号定义在errno.h或它所包含的头文件中
        一个程序只需独占某个资源很短时间（称为临界区），就要在进入临界区之前使用open创建锁文件，退出临界区时用unlink删除该锁文件
        需要代码中预先定义处理
    
    区域锁定：
        文件中的某个特定部分被锁定，但其他程序可以访问这个文件中的其他部分，这被称为文件段锁定或文件区域锁定
        使用fcntl系统调用和使用lockf调用均可实现，lockf一般作为fcntl的备选接口
        fcntl和lockf的锁定机制不能同时工作，它们使用不同的底层实现，不能混合使用
        
        int fcntl(int fildes, int command, ...);    （fcntl.h）
        对一个打开的文件描述符进行操作，根据command参数的设置完成不同的任务
        fcntl用于文件锁定的命令选项：
            F_GETLK
            F_SETLK
            F_SETLKW
        使用这些命令选项时，fcntl第三个参数必须是一个指向flock结构的指针
        int fcntl(int fildes, int command, struct flock *flock_structure);
        flock（文件锁）包含成员：
            short l_type
            short l_whence，取值必须是SEEK_SET、SEEK_CUR、SEEK_END（unistd.h）中的一个，对应文件头、当前位置、文件尾
            off_t l_start，是该区域的第一个字节
            off_t l_len，    该区域的字节数
            pid_t l_pid
        l_type的取值（fcntl.h中）：
            F_RDLCK，共享（读）锁，不同进程可以拥有文件同一区域上的共享锁，有一进程获得共享锁，其他进程就不能再获得该区域上的独占锁，为获得共享锁，文件必须以 读 或 读写方式打开
            F_UNLCK，解锁，用来清除锁
            F_WRLCK，独占（写）锁，只有一个进程可以在文件的任一特定区域拥有一把独占锁，一个进程拥有独占锁，其他进程就无法在该区域上获得任何类型的锁，独占锁以 写 或 读写方式打开
        l_whence、l_start、l_len定义文件中的一个区域，连续的字节集合，l_whence通常被设为SEEK_SET
        l_pid，用来记录持有锁的进程
        
        文件中的每个字节在任一时刻只能拥有一种类型的锁：共享锁、独占锁或解锁
        F_GETLK命令：
            用于获取fildes打开的文件的锁信息，不会尝试去锁定文件
            调用进程把想创建的锁类型信息传递给fcntl，使用F_GETLK命令的fcntl就会返回将会阻止获得锁的任何信息
            使用F_GETLK调用查看文件中某个区域的当前锁状态，应该设置flock结构表明需要的锁类型，并定义文件区域
            成功返回非-1，如果文件已锁定从而阻止锁请求成功执行，fcntl会覆盖flock结构，如果锁请求可以成功执行，flock结构将保持不变
            F_GETLK调用无法获得信息，将返回-1
            F_GETLK调用成功，必须检查flock结构的内容判断其是否被修改过，因为l_pid被设置为持有锁的进程，通过检查这个字段就可以很方便地判断出是否被修改过
        F_SETLK命令：
            对fildes指向的文件的某个区域加锁或解锁
            l_pid，不使用
            l_type，共享锁（只读）取值F_RDLCK，独占锁（写）取值F_UNLCK，解锁为F_UNLCK
            加锁区域，l_start、l_whence、l_len定义
            失败返回-1，否则非-1值
        F_SETLKW命令：
            与F_SETLK命令作用相同
            在无法获取锁时，将等待直到可以为止
            一旦开始等待，只有在可以获取锁或收到一个信号时才返回
        程序对文件拥有的所有锁都将在相应的文件描述符被关闭时自动清除，程序结束时也会自动清除各种锁
        
    锁定状态下的读写操作：
        对文件区域加锁之后，必须使用底层的read和write调用来访问文件中的数据，而不要使用fread和fwrite调用
        fread和fwrite会对读写的数据进行缓存，从而导致数据不一致
        如：缓存200个字节，只对前100字节锁定，另一程序对后100字节进行修改后，第一个程序对后100字节操作时，处理的是缓存的100字节，而不是修改后的100字节
        
        被写锁（独占）锁定的文件区域不能被其他程序加任何锁
        别读锁（共享）锁定的文件区域可以加读锁，不能加写锁
    
    文件锁的竞争：
        多个程序争夺文件同一区域上的锁，对已经被锁定的区域再次加锁
        F_UNLCK，解锁请求最终的结果取决于这个程序在文件的指定区域有没有设置任何锁
        F_SETLKW，等待直到指定区域可以获得锁为止
    
    其他锁命令：
        int lockf(int fildes, int function, off_t size_to_lock);    （unistd.h）
        function的取值：
            F_ULOCK，解锁
            F_LOCK，设置独占锁
            F_TLOCK，测试并设置独占锁        
            F_TEST，测试其他程序设置的锁
        size_to_lock是操作的字节数，从文件的当前偏移值开始计算
        同fcntl一样，设置的所有锁都是建议锁，并不会真正地阻止读写文件中的数据，对锁的检测是程序的责任
        lockf、fcntl二者只能选择一种使用
    
    死锁：
        deadlock 或 deadly embrace
        当有多个程序都在等待获得锁时，就需要考虑是否会发生死锁
        参考：并发和分布式程序设计原理

#### 数据库

    可以存储长度可变的数据记录
    数据库使用索引来有效地存储和检索数据，索引可以是一个任意的字符串
    
    dbm数据库：
        dbm适合于存储相对比较静态的索引化数据，索引化的文件存储系统
        使用RPM的Linux发行版本（RedHat、SUSE等）就是用dbm储存已安装软件包的信息
        dbm是一个很轻量级的软件，非常容易被编译进一个可发布的二进制文件中，无需安装独立的数据库服务器
        使用索引存储可变长的数据结构，然后通过索引或顺序扫描数据库来检索结构
        适用于处理那些被频繁访问但却很少被更新的数据，创建数据项时非常慢，检索时非常快
        dbm有不同的版本，GNU的gdbm，ndbm等，ndbm已由X/Open组织标准化
        gdbm且默认支持ndbm兼容模式的情况下（Red Hat）：
            使用ndbm.h头文件，编译时使用 -I/usr/include/gdbm（包含头文件），-Igdbm（链接gdbm库）
        gdbm，需要明确指定ndbm兼容模式，在链接主函数库之前链接兼容库（Ubuntu、SUSE）：
            使用gdbm-ndbm.h，编译行 -I/usr/include/gdbm， -lgdbm_compat -lgdbm（链接其他的兼容库）
        gdbm以兼容模式安装：gcc -o xxx -I/usr/include/gdbm xxx.c -lgdbm
        gdbm未以兼容模式安装：gcc -o xxx -I/usr/include/gdbm xxx.c -lgdbm_compat -lgdbm
    
    dbm例程：
        dbm由头文件和库文件组成，库文件必须编译时链接
        库文件简称为dbm，GNU的dbm实现，编译时使用-lgdbm，头文件是ndbm.h
        dbm数据库的基本元素是需要储存的数据块以及与它关联的在检索数据时用作关键字的数据块
        每个dbm数据库必须针对每个要存储的数据块有一个唯一的关键字
        关键字被用作存储数据的索引，dbm对关键字和数据没有限制
        ndbm.h中定义了datum类型（typedef定义），确切内容依赖具体实现，至少包含：
            void *dptr;（指向数据的起始点）     size_t dsize;（包含数据的长度）
        待存储的数据或用来访问它的索引都是通过datum类型来引用的
        打开一个dbm数据库时，会创建两个物理文件，分别是.pag和.dir，并返回一个dbm指针，用来访问这两个文件
        （有些实现中，这两个文件被合并到一起，打开数据库只会创建一个文件）
        dbm工作在非结构化的二进制数据库基础上
    
    dbm访问函数：
        DBM *dbm_open(const char *filename, int file_open_flags, mode_t file_mode);
        int dbm_store(DBM *database_descriptor, datum key, datum content, int store_mode);
        datum dbm_fetch(DBM *database_descriptor, datum key);
        void dbm_close(DBM *database_descriptor);   （ndbm.h）
        
        dbm_open：打开已有的数据库，或创建新数据库，filename是基本文件名，不包含.dir或 .pag后缀
            其余参数与open函数的第二个、第三个参数一样可以使用相同的#define定义
            第二个参数控制数据库的读、写或读写权限，创建新数据库，标志必须与O_CREAT进行二进制，第三个参数指定文件初始权限
            失败返回 (DBM *)0
        dbm_store：把数据存储到数据库，store_mode用于控制当以一个已有的关键字来存储数据时会发生的情况
            mode为dbm_insert时（key重复），存储操作将失败并返回1；为dbm_replace时，新数据将覆盖已有数据并且返回0，其他错误，dbm_store返回负值
        dbm_fetch：从数据库中检索数据，没有找到关键字dptr将被设为null，datum中仅包含一个指向数据的指针，实际数据依然保存在dbm库本地存储空间中，需要把数据复制到变量中
        dbm_close：关闭dbm_open打开的数据库
    
    其他dbm函数：
        int dbm_delete(DBM *database_descriptor, datum key);    //从数据库中删除数据项，成功返回0
        int dbm_error(DBM *database_descriptor);        //只是用于测试数据库中是否有错误发生，没有返回0
        int dbm_clearerr(DBM *database_descriptor);     //用于清除数据库中所有已被置位的错误条件标志
        datum dbm_firstkey(DBM *database_descriptor);   
        datum dbm_nextkey(DBM *database_descriptor);  //与上面成对使用来扫描数据库中的所有关键字
            for(key = dbm_firstkey(db_ptr)); key.dptr; key = dbm_nextkey(db_ptr);
    
    Linux同UNIX一样，使用一个单独的换行符来表明一行的结束

#### 总结

    Linux的内存系统：按需换页虚拟内存、内存管理系统保护OS和其他进程免受非法内存访问侵害
    文件锁定功能：多个程序访问数据时协调工作，二进制信号量机制、共享锁和独占锁锁住同一文件的不同部分
    dbm库：使用非常灵活的索引布局来存储和高效检索任意数据块